[[ -v __features && -n ${__features[keywords]:-} ]] && return

unset   -v  __features
declare -Ag __features=([keywords]=1)

require () {
  local feature_spec=$1
  local feature
  local IFS
  local extension
  local extensions=( .rubsh .bash .sh '' )
  local file
  local path

  feature=${1##*/}
  feature=${feature%.*}
  [[ -n ${__features[$feature]:-} ]] && return
  if [[ $feature_spec == */* ]]; then
    for extension in "${extensions[@]}"; do
      [[ -e $feature_spec$extension ]] && break
    done
    file=$feature_spec$extension
  else
    [[ -n ${RUBSH_PATH:-} ]] || return
    IFS=:
    for path in $RUBSH_PATH; do
      for extension in "${extensions[@]}"; do
        [[ -e $path/$feature_spec$extension ]] && break 2
      done
    done
    file=$path/$feature_spec$extension
  fi
  [[ -e $file ]] || return
  printf 'eval __features[%s]=1; source %s\n' "$feature" "$(readlink -f "$file")"
}

$(require init)
$(require util)

class () {
  local body
  local class
  local method
  local methods=()
  local statement
  local self
  local super

  __inspect __localh
  __stack+=( "$__" )
  if [[ $1 == 'Â«' ]]; then
    self=${__localh[$2]}_singleton
    super=${__superh[$self]}
  else
    __id_from_constant "$1"
    self=$__   # not local
    __id_from_constant "${3:-Object}"
    super=$__
  fi
  [[ -z ${2:-} || $2 == ':' ]] || return
  [[ -n ${2:-} ]] && {
    [[ -z ${__classesh[$self]:-}  ]] || return
    [[ -n ${__classesh[$super]:-} ]] || return
  }
  unset -f "${!__self_methodsh[@]}"
  __inspect __self_methodsh
  __methods_stack+=( "$__" )
  [[ -n ${__classesh["$self"_singleton]:-} ]] && class="$self"_singleton || class=class
  methods=( ${__methodsh[$class]:-} )
  while [[ -n ${__superh[$class]:-} ]]; do
    class=${__superh[$class]}
    methods+=( ${__methodsh[$class]:-} )
  done
  for method in "${methods[@]:-}"; do
    [[ -n $method         ]] || break
    [[ $method == 'class' ]] && continue
    printf -v statement 'function %s { local self=$self; __dispatch "$@" ;}' "$method"
    eval "$statement"
    __self_methodsh[$method]=1
  done
  [[ -n ${__classesh[$self]:-} ]] && { __=nil; return ;}
  __superh[$self]=$super
  __superh["$self"_singleton]="$super"_singleton
  printf -v statement 'function %s { local self=%s; __dispatch "$@" ;}' "$1" "$self"
  eval "$statement"
  __constanth[$1]=$self
  __classesh[$self]=1
  __classh[$self]="$self"_singleton
  __classh["$self"_singleton]="$self"_singleton
  __typeh[$self]=class
  __typeh["$self"_singleton]=class
  __singletonh["$self"_singleton]=1
  __ivarh[$self.name]=$1
  __ivarh["$self"_singleton.attached]=$self
  __=nil
}

def () {
  local method=$1
  local body=${2:-$(</dev/stdin)}
  local self

  self=${__localh[self]}
  __method_bodyh[$self#$method]=$body
  __methodsh[$self]+=" $method"
  printf -v statement 'function %s { local self=$self; __dispatch "$@" ;}' "$method"
  eval "$statement"
  __=nil
}

__dispatch () {
  local method=${1-.inspect}; shift ||:
  local class
  local statement

  class=${__classh[$self]}
  method=${method#.}
  while [[ -z ${__method_bodyh[$class#$method]:-} ]]; do
    [[ -n ${__superh[$class]:-} ]] || return
    class=${__superh[$class]}
  done
  printf -v statement 'function __ { %s ;}; __ "$self" "$@"' "${__method_bodyh[$class#$method]}"
  unset -v class method
  eval "$statement"
}

rubend () {
  eval __localh="${__stack[-1]}"
  unset -v __stack[-1]
  unset -f "${!__self_methodsh[@]}"
  eval __self_methodsh="${__methods_stack[-1]}"
  unset -v  __methods_stack[-1]
  for method in "${!__self_methodsh[@]}"; do
    [[ $method == 'class' ]] && continue
    printf -v statement 'function %s { local self=$self; __dispatch "$@" ;}' "$method"
    eval "$statement"
  done
}

class Class
  def new <<'  end'
    local class=$1
    local var=$2
    local id
    local statement

    __next_id
    id=$__
    printf -v statement 'function %s { local self=%s; __dispatch "$@" ;}' "$var" "$id"
    eval "$statement"
    __classh[$id]=$class
    __localh[$var]=$id
    __typeh[$id]=object
    __=$id
  end
rubend

__=''

# vim: ft=sh
