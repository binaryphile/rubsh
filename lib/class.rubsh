class Class : Object; {
  def ancestors <<'  end'
    local class=$1
    local ancestors=( $class )

    while [[ -n ${__superh[$class]-} ]]; do
      class=${__superh[$class]}
      ancestors+=( "$class" )
    done
    __inspect ancestors
    __classh[__]=Array
  end

  def declare <<'  end'
    local class=$1
    local self=$2; shift 2
    local value=${1-}
    local format

    value=$(declare -p value)
    value=${value#*=}
    case $class in
      'Array' ) printf 'eval declare -a %s=%s; %s .new %s\n' "$self" "${value:1:-1}" "$class" "$self" ;;
      'Hash'  ) printf 'eval declare -A %s=%s; %s .new %s\n' "$self" "${value:1:-1}" "$class" "$self" ;;
      *       ) printf 'eval declare -- %s=%s; %s .new %s\n' "$self" "$value"        "$class" "$self" ;;
    esac
    __=$value
    __classh[__]=String
  end

  def instance_methods <<'  end'
    local class=$1
    local inherited=${2-true}
    local instance_methods=( ${__methodsh[$class]} )

    case $inherited in
      'false' ) ;;
      'true'  )
        while [[ -n ${__superh[$class]-} ]]; do
          class=${__superh[$class]}
          instance_methods+=( ${__methodsh[$class]} )
        done
        ;;
      * ) return 1;;
    esac
    __inspect instance_methods
    __classh[__]=Array
  end

  def new <<'  end'
    local class=$1
    local self=$2; shift 2
    local value=${1-}
    local format
    local stdout
    local statement

    printf -v statement 'function %s { __dispatch "$@" ;}' "$self"
    eval "$statement"
    [[ $class == 'Class' ]] && __superh[$self]=Object
    __classh[$self]=$class
    __=''
    [[ -z $value ]] && return
    declare -f "$value" >/dev/null 2>&1 && {
      "$@"
      value=$__
    }
    case $value in
      '('* ) format='%s=%s';;
         * ) format='%s=%q';;
    esac
    printf -v statement "$format" "$self" "$value"
    eval "$statement"
    __=$value
    __classh[__]=String
  end

  def superclass <<'  end'
    local class=$1

    __=\"${__superh[$class]-}\"
    __classh[__]=String
  end
}

# vim: ft=sh
