$(require object)
# $(require ruby  )
# $(require util  )

__dispatch () {
  local method=${1-.inspect}; shift ||:
  local self=${FUNCNAME[1]}
  local class
  local i
  local id
  local rest=()
  local statement

  class=${__classh[${!self}]}
  [[ $method != '.'* ]] && {
    case $method in
      '=' ) method=.=;;
      *   )
        case ${1-} in
          '='   ) set -- "$method" "${@:2}"; method=.new     ;;
          ':='  ) set -- "$method" "${@:2}"; method=.declare ;;
          * )
            [[ $class == 'Class' ]] || return
            $("$self" .declare anon "$method")
            anon "$@"
            return
            ;;
          * ) return 1;;
        esac
        ;;
    esac
  }
  method=${method#.}
  while [[ -z $(eval "echo \${__${method}_classesh[${!class}]:-}") ]]; do
    [[ -n ${__superh[${!class}]:-} ]] || return
    class=${__superh[${!class}]}
  done
  [[ -n ${__method_bodyh[${!class}#$method]:-} ]] || return
  [[ ${1-} == '{' ]] && {
    for (( i = 1; i <= $#; i++ )); do
      [[ ${!i} == '}' ]] && break;
    done
    [[ ${!i} == '}' ]] || return
    rest=( "${@:i+1}" )
    set -- "${@:2:i-2}"
  }
  printf -v statement 'function __ { %s ;}; __ "$self" "$@"' "${__method_bodyh[${!class}#$method]}"
  eval "$statement"
  ! (( ${#rest[@]} )) && return
  "${__classh[__]}" "$__" "${rest[@]}"
}

rubsh_init () {
  local funcs
  local vars

  funcs=(
    Init_Objects
    rubsh_init
  )

  vars=(
    Class
    FalseClass
    NilClass
    Object
    RUBSH_LIB
    TrueClass
    __
    __Class
    __FalseClass
    __NilClass
    __Object
    __TrueClass
    __class
    __classesh
    __top_self
    self
  )
  unset -v "${vars[@]}"

  Init_Objects

  __class=Object
  self=__top_self

  unset -f "${funcs[@]}"
  __=''
}

# vim: ft=sh
